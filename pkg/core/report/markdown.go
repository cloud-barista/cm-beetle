/*
Copyright 2019 The Cloud-Barista Authors.
Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at
    http://www.apache.org/licenses/LICENSE-2.0
Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

// Package report provides migration report markdown formatting
package report

import (
	"fmt"
	"strings"

	"github.com/cloud-barista/cm-beetle/pkg/core/summary"
)

// GenerateMigrationReportMarkdown generates a markdown formatted migration report
func GenerateMigrationReportMarkdown(report *MigrationReport) string {
	var md strings.Builder

	// Header
	md.WriteString("# üöÄ Infrastructure Migration Report\n\n")
	md.WriteString("This report provides a comprehensive summary of the infrastructure migration from on-premise to cloud environment, including detailed information about migrated resources, costs, and configurations.\n\n")
	md.WriteString(fmt.Sprintf("*Report generated: %s*\n\n", report.Metadata.GeneratedAt.Format("2006-01-02 15:04:05")))
	md.WriteString("---\n\n")

	// Executive Summary
	writeExecutiveSummary(&md, &report.ExecutiveSummary, &report.Metadata)

	// Migrated Resources Overview (7 Types)
	writeMigratedResourcesOverview(&md, report)

	// VM Migration Status
	writeVmMigrationStatus(&md, report)

	// VM Spec Status
	writeVmSpecStatus(&md, report)

	// VM Image Status
	writeVmImageStatus(&md, report)

	// Security Group Status
	writeSecurityGroupStatus(&md, report)

	// VPC(VNet) and Subnet Status
	writeNetworkStatus(&md, report)

	// SSH Key Status
	writeSshKeyStatus(&md, report)

	// Cost Summary
	writeCostSummary(&md, &report.CostSummary)

	// Footer
	md.WriteString("\n---\n")
	md.WriteString("\n*Report generated by CM-Beetle*\n")

	return md.String()
}

func writeExecutiveSummary(md *strings.Builder, summary *ExecutiveSummary, metadata *ReportMetadata) {
	md.WriteString("## üìä Migration Summary\n\n")

	// Target Cloud Information (ÏµúÏö∞ÏÑ†)
	md.WriteString(fmt.Sprintf("**Target Cloud:** %s\n\n", summary.TargetCloud))
	md.WriteString(fmt.Sprintf("**Target Region:** %s\n\n", summary.TargetRegion))

	// Metadata Information
	md.WriteString(fmt.Sprintf("**Namespace:** %s | **MCI ID:** %s\n\n",
		metadata.Namespace, metadata.MciID))

	// Migration Status
	md.WriteString(fmt.Sprintf("**Migration Status:** %s\n\n", summary.MigrationStatus))
	md.WriteString(fmt.Sprintf("**Total Servers:** %d\n\n", summary.TotalServers))
	md.WriteString(fmt.Sprintf("**Migrated Servers:** %d\n\n", summary.MigratedServers))

	if summary.FailedServers > 0 {
		md.WriteString(fmt.Sprintf("‚ö†Ô∏è **Failed Servers:** %d\n\n", summary.FailedServers))
	}

	// Cost Estimate
	if summary.MonthlyCostUSD > 0 {
		md.WriteString(fmt.Sprintf("**üí∞ Estimated Monthly Cost:** $%.2f USD\n\n", summary.MonthlyCostUSD))
	}

	md.WriteString("---\n\n")
}

func writeMigratedResourcesOverview(md *strings.Builder, report *MigrationReport) {
	md.WriteString("## üì¶ Migrated Resources Overview\n\n")
	md.WriteString("Summary of key infrastructure resources created or configured in the target cloud:\n\n")

	md.WriteString("| # | Resource Type | Count | Status | Details |\n")
	md.WriteString("|---|---------------|-------|--------|----------|\n")

	// 1. Virtual Machines (VMs)
	vmCount := 0
	runningCount := 0
	if report.TargetDetails != nil && report.TargetDetails.ComputeResources.Vms != nil {
		vmCount = len(report.TargetDetails.ComputeResources.Vms)
		for _, vm := range report.TargetDetails.ComputeResources.Vms {
			if vm.Status == "Running" {
				runningCount++
			}
		}
	}
	vmStatus := "‚úÖ Created"
	vmCountStr := fmt.Sprintf("%d", vmCount)
	vmDetails := fmt.Sprintf("%d running, %d total", runningCount, vmCount)
	if vmCount == 0 {
		vmStatus = "‚ö†Ô∏è Not created"
		vmCountStr = "0"
		vmDetails = "No VMs migrated"
	}
	md.WriteString(fmt.Sprintf("| 1 | **Virtual Machine** | %s | %s | %s |\n", vmCountStr, vmStatus, vmDetails))

	// 2. VM Specs
	vmSpecCount := 0
	vmSpecDetails := "No specs used"
	if report.TargetDetails != nil && report.TargetDetails.ComputeResources.Vms != nil {
		specs := make(map[string]bool)
		for _, vm := range report.TargetDetails.ComputeResources.Vms {
			if vm.Spec.Name != "" {
				specs[vm.Spec.Name] = true
			}
		}
		vmSpecCount = len(specs)
		if vmSpecCount > 0 {
			specList := []string{}
			for spec := range specs {
				specList = append(specList, spec)
			}
			if len(specList) <= 3 {
				vmSpecDetails = strings.Join(specList, ", ")
			} else {
				vmSpecDetails = fmt.Sprintf("%s, ... (+%d more)", strings.Join(specList[:3], ", "), len(specList)-3)
			}
		}
	}
	vmSpecStatus := "‚úÖ Selected"
	vmSpecCountStr := fmt.Sprintf("%d", vmSpecCount)
	if vmSpecCount == 0 {
		vmSpecStatus = "‚ö†Ô∏è Not selected"
		vmSpecCountStr = "0"
	}
	md.WriteString(fmt.Sprintf("| 2 | **VM Spec** | %s | %s | %s |\n", vmSpecCountStr, vmSpecStatus, vmSpecDetails))

	// 3. VM OS Images
	vmImageCount := 0
	vmImageDetails := "No images used"
	if report.TargetDetails != nil && report.TargetDetails.ComputeResources.Vms != nil {
		images := make(map[string]bool)
		osTypes := make(map[string]bool)
		for _, vm := range report.TargetDetails.ComputeResources.Vms {
			if vm.Image.Name != "" {
				images[vm.Image.Name] = true
			}
			if vm.Image.OsType != "" {
				osTypes[vm.Image.OsType] = true
			}
		}
		vmImageCount = len(images)
		if vmImageCount > 0 {
			// Collect OS types as comma-separated list
			osTypeList := make([]string, 0, len(osTypes))
			for osType := range osTypes {
				osTypeList = append(osTypeList, osType)
			}
			if len(osTypeList) > 0 {
				vmImageDetails = strings.Join(osTypeList, ", ")
			} else {
				vmImageDetails = fmt.Sprintf("%d OS images", vmImageCount)
			}
		}
	}
	vmImageStatus := "‚úÖ Selected"
	vmImageCountStr := fmt.Sprintf("%d", vmImageCount)
	if vmImageCount == 0 {
		vmImageStatus = "‚ö†Ô∏è Not selected"
		vmImageCountStr = "0"
	}
	md.WriteString(fmt.Sprintf("| 3 | **VM OS Image** | %s | %s | %s |\n", vmImageCountStr, vmImageStatus, vmImageDetails))

	// 4. VNet (VPC) - ÎÑ§Ìä∏ÏõåÌÅ¨ Ïù∏ÌîÑÎùº
	vnetStatus := "‚úÖ Created"
	vnetName := report.NetworkAnalysis.TargetNetwork.VNetName
	vnetCount := "1"
	vnetDetails := fmt.Sprintf("%s, CIDR: %s", vnetName, report.NetworkAnalysis.TargetNetwork.VNetCIDR)
	if vnetName == "" {
		vnetStatus = "‚ö†Ô∏è Not created"
		vnetCount = "0"
		vnetDetails = "VNet not found"
	}
	md.WriteString(fmt.Sprintf("| 4 | **VNet (VPC)** | %s | %s | %s |\n", vnetCount, vnetStatus, vnetDetails))

	// 5. Subnet - VNet ÌïòÏúÑ Î¶¨ÏÜåÏä§
	subnetStatus := "‚úÖ Created"
	subnetCIDR := report.NetworkAnalysis.TargetNetwork.SubnetCIDR
	subnetCount := "1"
	subnetDetails := fmt.Sprintf("%s (in %s)", subnetCIDR, vnetName)
	if subnetCIDR == "" {
		subnetStatus = "‚ö†Ô∏è Not created"
		subnetCount = "0"
		subnetDetails = "Subnet not found"
	}
	md.WriteString(fmt.Sprintf("| 5 | **Subnet** | %s | %s | %s |\n", subnetCount, subnetStatus, subnetDetails))

	// 6. Security Group - Î≥¥Ïïà ÏÑ§Ï†ï
	// Use actual Security Group count from TargetDetails instead of SecurityAnalysis.Conversions
	sgCount := 0
	totalRules := 0
	if report.TargetDetails != nil && report.TargetDetails.SecurityResources.SecurityGroups != nil {
		sgCount = len(report.TargetDetails.SecurityResources.SecurityGroups)
		for _, sg := range report.TargetDetails.SecurityResources.SecurityGroups {
			totalRules += len(sg.Rules)
		}
	}
	sgStatus := "‚úÖ Created"
	sgCountStr := fmt.Sprintf("%d security groups", sgCount)
	sgDetails := fmt.Sprintf("Total %d rules in %d sgs", totalRules, sgCount)
	if sgCount == 0 {
		sgStatus = "‚ö†Ô∏è Not created"
		sgCountStr = "0 security groups"
		sgDetails = "No security groups"
	}
	md.WriteString(fmt.Sprintf("| 6 | **Security Group** | %s | %s | %s |\n", sgCountStr, sgStatus, sgDetails))

	// 7. SSH Key - Ï†ëÍ∑º Ï†úÏñ¥
	sshKeyCount := 0
	if report.TargetDetails != nil && report.TargetDetails.SecurityResources.SshKeys != nil {
		sshKeyCount = len(report.TargetDetails.SecurityResources.SshKeys)
	}
	sshKeyStatus := "‚úÖ Created"
	sshKeyName := fmt.Sprintf("%d keys", sshKeyCount)
	sshKeyDetails := "For VM access control"
	if sshKeyCount == 0 {
		sshKeyStatus = "‚ö†Ô∏è Not created"
		sshKeyName = "N/A"
		sshKeyDetails = "No SSH key created"
	}
	md.WriteString(fmt.Sprintf("| 7 | **SSH Key** | %s | %s | %s |\n", sshKeyName, sshKeyStatus, sshKeyDetails))

	md.WriteString("\n---\n\n")
}

func getTotalTargetRules(conversions []SecurityConversion) int {
	total := 0
	for _, conv := range conversions {
		total += conv.TargetRules
	}
	return total
}

func countUniqueVMSpecs(mappings []SourceTargetMapping) int {
	specs := make(map[string]bool)
	for _, mapping := range mappings {
		if mapping.TargetVM.SpecName != "" {
			specs[mapping.TargetVM.SpecName] = true
		}
	}
	return len(specs)
}

func getVMSpecList(mappings []SourceTargetMapping) string {
	specs := make(map[string]bool)
	for _, mapping := range mappings {
		if mapping.TargetVM.SpecName != "" {
			specs[mapping.TargetVM.SpecName] = true
		}
	}
	if len(specs) == 0 {
		return "-"
	}
	specList := []string{}
	for spec := range specs {
		specList = append(specList, spec)
	}
	if len(specList) > 3 {
		return fmt.Sprintf("%s, %s, %s, +%d more", specList[0], specList[1], specList[2], len(specList)-3)
	}
	return strings.Join(specList, ", ")
}

func countRunningVMs(mappings []SourceTargetMapping) int {
	count := 0
	for _, mapping := range mappings {
		if strings.ToLower(mapping.TargetVM.Status) == "running" {
			count++
		}
	}
	return count
}

// writeVmMigrationStatus writes VM migration status section
func writeVmMigrationStatus(md *strings.Builder, report *MigrationReport) {
	md.WriteString("## üíª Virtual Machines (VMs)\n\n")

	targetVMs := 0
	sourceServers := 0
	if report.TargetDetails != nil && report.TargetDetails.ComputeResources.Vms != nil {
		targetVMs = len(report.TargetDetails.ComputeResources.Vms)
	}
	if report.SourceDetails != nil && report.SourceDetails.ComputeResources.Servers != nil {
		sourceServers = len(report.SourceDetails.ComputeResources.Servers)
	}

	md.WriteString(fmt.Sprintf("**Summary:** %d VM(s) have been successfully created in the target cloud, migrated from %d source server(s) in the on-premise infrastructure.\n\n", targetVMs, sourceServers))

	md.WriteString("| No. | Migrated VM | Source Server |\n")
	md.WriteString("|-----|-------------|---------------|\n")

	if report.TargetDetails != nil && report.TargetDetails.ComputeResources.Vms != nil {
		for i, vm := range report.TargetDetails.ComputeResources.Vms {
			// Extract sourceMachineId from VM name
			sourceMachineId := extractSourceMachineId(vm.Name)

			// Format VM info
			vmInfo := fmt.Sprintf("**VM Name:** %s<br>**VM ID:** %s<br>**Label(sourceMachineId):** %s",
				vm.Name, vm.CspVmId, sourceMachineId)

			// Get source server info
			sourceInfo := extractSourceServerInfoDetailed(vm.Name, report.SourceDetails)

			md.WriteString(fmt.Sprintf("| %d | %s | %s |\n", i+1, vmInfo, sourceInfo))
		}
	}

	md.WriteString("\n---\n\n")
}

// writeVmSpecStatus writes VM Spec status section
func writeVmSpecStatus(md *strings.Builder, report *MigrationReport) {
	md.WriteString("## ‚öôÔ∏è VM Specs\n\n")

	specs := make(map[string]bool)
	if report.TargetDetails != nil && report.TargetDetails.ComputeResources.Vms != nil {
		for _, vm := range report.TargetDetails.ComputeResources.Vms {
			if vm.Spec.Name != "" {
				specs[vm.Spec.Name] = true
			}
		}
	}

	md.WriteString(fmt.Sprintf("**Summary:** %d VM specification(s) have been selected and used for the migrated VMs.\n\n", len(specs)))

	md.WriteString("| No. | Migrated VM | VM Spec | Source Server | Source Server Spec |\n")
	md.WriteString("|-----|-------------|---------|---------------|--------------------|\n")

	if report.TargetDetails != nil && report.TargetDetails.ComputeResources.Vms != nil {
		for i, vm := range report.TargetDetails.ComputeResources.Vms {
			vmName := vm.Name
			specInfo := formatVmSpecInfo(vm)
			sourceInfo := extractSourceServerInfoDetailed(vm.Name, report.SourceDetails)
			sourceSpec := formatSourceServerSpecInfo(vm.Name, report.SourceDetails)
			md.WriteString(fmt.Sprintf("| %d | %s | %s | %s | %s |\n", i+1, vmName, specInfo, sourceInfo, sourceSpec))
		}
	}

	md.WriteString("\n---\n\n")
}

// writeVmImageStatus writes VM Image status section
func writeVmImageStatus(md *strings.Builder, report *MigrationReport) {
	md.WriteString("## üíø VM OS Images\n\n")

	images := make(map[string]bool)
	if report.TargetDetails != nil && report.TargetDetails.ComputeResources.Vms != nil {
		for _, vm := range report.TargetDetails.ComputeResources.Vms {
			if vm.Image.Name != "" {
				images[vm.Image.Name] = true
			}
		}
	}

	md.WriteString(fmt.Sprintf("**Summary:** %d OS image(s) have been selected and used for the migrated VMs.\n\n", len(images)))

	md.WriteString("| No. | Migrated VM | VM OS Image Info | Source Server | Source OS |\n")
	md.WriteString("|-----|-------------|------------------|---------------|-----------|\n")

	if report.TargetDetails != nil && report.TargetDetails.ComputeResources.Vms != nil {
		for i, vm := range report.TargetDetails.ComputeResources.Vms {
			vmName := vm.Name
			imageInfo := fmt.Sprintf("**Image ID:** %s<br>**OS Type:** %s<br>**OS Distribution:** %s", vm.Image.Id, vm.Image.OsType, vm.Image.Distribution)
			sourceInfo := extractSourceServerInfoDetailed(vm.Name, report.SourceDetails)
			sourceOS := extractSourceOSInfoDetailed(vm.Name, report.SourceDetails)
			md.WriteString(fmt.Sprintf("| %d | %s | %s | %s | %s |\n", i+1, vmName, imageInfo, sourceInfo, sourceOS))
		}
	}

	md.WriteString("\n---\n\n")
}

// writeSecurityGroupStatus writes Security Group status section
func writeSecurityGroupStatus(md *strings.Builder, report *MigrationReport) {
	md.WriteString("## üîí Security Groups\n\n")

	sgCount := 0
	totalRules := 0
	if report.TargetDetails != nil && report.TargetDetails.SecurityResources.SecurityGroups != nil {
		sgCount = len(report.TargetDetails.SecurityResources.SecurityGroups)
		for _, sg := range report.TargetDetails.SecurityResources.SecurityGroups {
			totalRules += len(sg.Rules)
		}
	}

	md.WriteString(fmt.Sprintf("**Summary:** %d security group(s) with %d security rule(s) have been created and configured for the migrated VMs.\n\n", sgCount, totalRules))

	if report.TargetDetails != nil && report.TargetDetails.SecurityResources.SecurityGroups != nil {
		for _, sg := range report.TargetDetails.SecurityResources.SecurityGroups {
			md.WriteString(fmt.Sprintf("### Security Group: %s\n\n", sg.Name))
			md.WriteString(fmt.Sprintf("**CSP ID:** %s | **VNet:** %s | **Rules:** %d\n\n", sg.CspSecurityGroupId, sg.VNetName, sg.RuleCount))

			// Display Assigned VMs
			assignedVMsList := getVMsUsingSecurityGroupList(sg.Name, report.TargetDetails)
			if len(assignedVMsList) > 0 {
				md.WriteString("**Assigned VMs:**\n\n")
				for _, vm := range assignedVMsList {
					sourceInfo := extractSourceServerInfoDetailed(vm, report.SourceDetails)
					md.WriteString(fmt.Sprintf("- **VM:** %s\n", vm))
					md.WriteString(fmt.Sprintf("  - **Source Server:** %s\n", strings.ReplaceAll(sourceInfo, "<br>", ", ")))
				}
				md.WriteString("\n")
			}

			// Display Security Rules Table
			md.WriteString("**Security Rules:**\n\n")
			md.WriteString("| No. | Direction | Protocol | Port | CIDR | Source Firewall Rule | Note |\n")
			md.WriteString("|-----|-----------|----------|------|------|----------------------|------|\n")

			for i, rule := range sg.Rules {
				sourceRule := matchSourceFirewallRule(rule, report.SourceDetails)
				note := ""
				if sourceRule != "-" && sourceRule != "" {
					note = "Migrated from source"
				} else {
					note = "Created by system"
				}
				md.WriteString(fmt.Sprintf("| %d | %s | %s | %s | %s | %s | %s |\n",
					i+1, rule.Direction, rule.Protocol, rule.FromPort, rule.Cidr, sourceRule, note))
			}

			md.WriteString("\n")
		}
	}

	md.WriteString("---\n\n")
}

// writeNetworkStatus writes VPC/VNet and Subnet status section
func writeNetworkStatus(md *strings.Builder, report *MigrationReport) {
	md.WriteString("## üåê VPC(VNet) and Subnets\n\n")

	md.WriteString("**Summary:** Virtual Private Cloud (VPC) and subnet infrastructure have been created based on the source server network information.\n\n")

	// VPC/VNet Table
	md.WriteString("### VPC(VNet)\n\n")
	md.WriteString("| No. | VPC(VNet) | CIDR Block |\n")
	md.WriteString("|-----|-----------|------------|\n")

	if report.TargetDetails != nil && report.TargetDetails.NetworkResources.VNets != nil {
		for i, vnet := range report.TargetDetails.NetworkResources.VNets {
			vnetInfo := fmt.Sprintf("**Name:** %s<br>**ID:** %s", vnet.Name, vnet.CspVNetId)
			md.WriteString(fmt.Sprintf("| %d | %s | %s |\n", i+1, vnetInfo, vnet.CidrBlock))
		}
	}

	md.WriteString("\n")

	// Subnet Table
	md.WriteString("### Subnets\n\n")
	md.WriteString("| No. | Subnet | CIDR Block | Associated VPC(VNet) |\n")
	md.WriteString("|-----|--------|------------|----------------------|\n")

	if report.TargetDetails != nil && report.TargetDetails.NetworkResources.VNets != nil {
		no := 1
		for _, vnet := range report.TargetDetails.NetworkResources.VNets {
			for _, subnet := range vnet.Subnets {
				subnetInfo := fmt.Sprintf("**Name:** %s<br>**ID:** %s", subnet.Name, subnet.CspSubnetId)
				md.WriteString(fmt.Sprintf("| %d | %s | %s | %s |\n", no, subnetInfo, subnet.CidrBlock, vnet.Name))
				no++
			}
		}
	}

	md.WriteString("\n")

	// Source Network Information
	if report.SourceDetails != nil && report.SourceDetails.NetworkResources.Networks != nil && len(report.SourceDetails.NetworkResources.Networks) > 0 {
		md.WriteString("### Source Network Information\n\n")
		for _, network := range report.SourceDetails.NetworkResources.Networks {
			md.WriteString(fmt.Sprintf("**CIDR:** %s | **Gateway:** %s | **Connected Servers:** %d\n\n", network.NetworkCIDR, network.Gateway, network.ServerCount))
		}
	}

	// Network Details by Server
	if report.SourceDetails != nil && report.SourceDetails.ComputeResources.Servers != nil {
		serverCount := len(report.SourceDetails.ComputeResources.Servers)
		md.WriteString(fmt.Sprintf("### Network Details by Server (%d servers)\n\n", serverCount))

		for idx, server := range report.SourceDetails.ComputeResources.Servers {
			md.WriteString(fmt.Sprintf("#### %d. %s\n\n", idx+1, server.Hostname))

			// Active Interfaces - Only show interfaces with IP or in 'up' state
			if len(server.Interfaces) > 0 {
				activeInterfaces := []summary.SourceInterfaceInfo{}
				for _, iface := range server.Interfaces {
					// Show only interfaces with IP addresses or in 'up' state
					if len(iface.IPv4CidrBlocks) > 0 || iface.State == "up" {
						activeInterfaces = append(activeInterfaces, iface)
					}
				}

				if len(activeInterfaces) > 0 {
					md.WriteString("**Active Interfaces:**\n\n")
					md.WriteString("| Interface | IP Address | State |\n")
					md.WriteString("|-----------|------------|-------|\n")

					for _, iface := range activeInterfaces {
						ipAddr := strings.Join(iface.IPv4CidrBlocks, ", ")
						if ipAddr == "" {
							ipAddr = "-"
						}
						state := iface.State
						if state == "" {
							state = "-"
						}

						md.WriteString(fmt.Sprintf("| %s | %s | %s |\n", iface.Name, ipAddr, state))
					}
					md.WriteString("\n")
				}
			}

			// Main Routes - Only show IPv4 default route and main routes
			if len(server.RoutingTable) > 0 {
				mainRoutes := []summary.SourceRoutingTableRow{}
				for _, route := range server.RoutingTable {
					// Show only IPv4 routes (exclude IPv6) and important routes
					if !strings.Contains(route.Destination, ":") {
						// Include default route (0.0.0.0/0) and /24 or smaller networks
						if route.Destination == "0.0.0.0/0" ||
							(strings.Contains(route.Destination, "/") &&
								!strings.HasPrefix(route.Destination, "fe80") &&
								!strings.HasPrefix(route.Destination, "ff00")) {
							mainRoutes = append(mainRoutes, route)
						}
					}
				}

				if len(mainRoutes) > 0 {
					md.WriteString("**Main Routes:**\n\n")
					md.WriteString("| Destination | Gateway | Interface |\n")
					md.WriteString("|-------------|---------||-----------|\n")

					for _, route := range mainRoutes {
						gateway := route.Gateway
						if gateway == "" {
							gateway = "on-link"
						}

						md.WriteString(fmt.Sprintf("| %s | %s | %s |\n", route.Destination, gateway, route.Interface))
					}
					md.WriteString("\n")
				}
			}
		}
	}

	md.WriteString("---\n\n")
}

// writeSshKeyStatus writes SSH Key status section
func writeSshKeyStatus(md *strings.Builder, report *MigrationReport) {
	md.WriteString("## üîë SSH Keys\n\n")

	sshKeyCount := 0
	if report.TargetDetails != nil && report.TargetDetails.SecurityResources.SshKeys != nil {
		sshKeyCount = len(report.TargetDetails.SecurityResources.SshKeys)
	}

	md.WriteString(fmt.Sprintf("**Summary:** %d SSH key(s) have been created for secure access to the migrated VMs.\n\n", sshKeyCount))

	md.WriteString("> **Note:** Due to security constraints and operational efficiency, it is challenging to transfer existing SSH keys from the source infrastructure. Therefore, new SSH key(s) have been generated and are commonly used across all migrated VMs. This approach ensures secure access while simplifying key management in the cloud environment.\n\n")

	if report.TargetDetails != nil && report.TargetDetails.SecurityResources.SshKeys != nil && len(report.TargetDetails.SecurityResources.SshKeys) > 0 {
		md.WriteString("| No. | SSH Key Name | CSP Key ID | Fingerprint | Usage |\n")
		md.WriteString("|-----|--------------|------------|-------------|-------|\n")

		for i, key := range report.TargetDetails.SecurityResources.SshKeys {
			usage := fmt.Sprintf("Used by all %d VMs", len(report.TargetDetails.ComputeResources.Vms))
			md.WriteString(fmt.Sprintf("| %d | %s | %s | %s | %s |\n", i+1, key.Name, key.CspSshKeyId, key.Fingerprint, usage))
		}
		md.WriteString("\n")
	}

	md.WriteString("---\n\n")
}

// Helper functions for extracting source information

// extractSourceMachineId extracts machine ID from VM name
func extractSourceMachineId(vmName string) string {
	// VM name format: "migrated-{machineId}-..."
	parts := strings.Split(vmName, "-")
	if len(parts) >= 6 {
		// Reconstruct full machine ID from parts (e.g., 0036e4b9-c8b4-e811-906e-000ffee02d5c)
		return fmt.Sprintf("%s-%s-%s-%s-%s", parts[1], parts[2], parts[3], parts[4], parts[5])
	}
	if len(parts) >= 2 {
		return parts[1]
	}
	return "N/A"
}

// extractSourceServerInfoDetailed extracts detailed source server information
func extractSourceServerInfoDetailed(vmName string, sourceDetails *summary.SourceInfraSummary) string {
	if sourceDetails == nil || sourceDetails.ComputeResources.Servers == nil {
		return "**Hostname:** N/A<br>**Machine ID:** N/A"
	}

	// Extract machine ID from VM name (format: "migrated-{MachineId}")
	machineID := extractSourceMachineId(vmName)

	// Match source server by machine ID field directly
	for _, server := range sourceDetails.ComputeResources.Servers {
		if server.MachineId == machineID {
			return fmt.Sprintf("**Hostname:** %s<br>**Machine ID:** %s", server.Hostname, server.MachineId)
		}
	}

	// If no match found, still show the machine ID extracted from VM name
	return fmt.Sprintf("**Hostname:** N/A<br>**Machine ID:** %s", machineID)
}

func extractSourceServerInfo(vmName string, sourceDetails *summary.SourceInfraSummary) string {
	if sourceDetails == nil || sourceDetails.ComputeResources.Servers == nil {
		return "N/A"
	}

	// Extract machine ID from VM name
	machineID := extractSourceMachineId(vmName)

	// Match by machine ID field
	for _, server := range sourceDetails.ComputeResources.Servers {
		if server.MachineId == machineID {
			return fmt.Sprintf("%s<br>%s", server.Hostname, server.MachineId)
		}
	}

	return fmt.Sprintf("Source server<br>%s", machineID)
}

func extractSourceSpecInfo(vmName string, sourceDetails *summary.SourceInfraSummary) string {
	if sourceDetails == nil || sourceDetails.ComputeResources.Servers == nil {
		return "N/A"
	}

	// Extract machine ID from VM name
	machineID := extractSourceMachineId(vmName)

	// Match by machine ID field
	for _, server := range sourceDetails.ComputeResources.Servers {
		if server.MachineId == machineID {
			return fmt.Sprintf("%d CPUs, %d Threads<br>%d GB RAM, %d GB Disk",
				server.CPU.CPUs, server.CPU.Threads, server.Memory.TotalGB, server.Disk.TotalGB)
		}
	}

	return "N/A"
}

func extractSourceOSInfo(vmName string, sourceDetails *summary.SourceInfraSummary) string {
	if sourceDetails == nil || sourceDetails.ComputeResources.Servers == nil {
		return "N/A"
	}

	// Extract machine ID from VM name
	machineID := extractSourceMachineId(vmName)

	// Match by machine ID field
	for _, server := range sourceDetails.ComputeResources.Servers {
		if server.MachineId == machineID {
			return fmt.Sprintf("%s %s", server.OS.Name, server.OS.Version)
		}
	}

	return "N/A"
}

func extractSourceOSInfoDetailed(vmName string, sourceDetails *summary.SourceInfraSummary) string {
	if sourceDetails == nil || sourceDetails.ComputeResources.Servers == nil {
		return "**PrettyName:** N/A<br>**Name:** N/A<br>**Version:** N/A"
	}

	// Extract machine ID from VM name
	machineID := extractSourceMachineId(vmName)

	// Match by machine ID field
	for _, server := range sourceDetails.ComputeResources.Servers {
		if server.MachineId == machineID {
			return fmt.Sprintf("**PrettyName:** %s<br>**Name:** %s<br>**Version:** %s",
				server.OS.PrettyName, server.OS.Name, server.OS.Version)
		}
	}

	return "**PrettyName:** N/A<br>**Name:** N/A<br>**Version:** N/A"
}

// formatVmSpecInfo formats VM spec information for display
func formatVmSpecInfo(vm summary.SummaryVmInfo) string {
	// Assuming Root Disk size is 50GB by default (this should be retrieved from actual VM data if available)
	rootDiskGB := 50
	return fmt.Sprintf("**Spec ID:** %s<br>**vCPUs:** %d<br>**Memory:** %.1f GB<br>**Root Disk:** %d GB",
		vm.Spec.Name, vm.Spec.VCpus, vm.Spec.MemoryGiB, rootDiskGB)
}

// formatSourceServerSpecInfo formats source server spec information for display
func formatSourceServerSpecInfo(vmName string, sourceDetails *summary.SourceInfraSummary) string {
	if sourceDetails == nil || sourceDetails.ComputeResources.Servers == nil {
		return "**CPUs:** N/A<br>**Threads:** N/A<br>**Memory:** N/A<br>**Root Disk:** N/A"
	}

	// Extract machine ID from VM name
	machineID := extractSourceMachineId(vmName)

	// Match by machine ID field
	for _, server := range sourceDetails.ComputeResources.Servers {
		if server.MachineId == machineID {
			return fmt.Sprintf("**CPUs:** %d<br>**Threads:** %d<br>**Memory:** %d GB<br>**Root Disk:** %d GB",
				server.CPU.CPUs, server.CPU.Threads, server.Memory.TotalGB, server.Disk.TotalGB)
		}
	}

	return "**CPUs:** N/A<br>**Threads:** N/A<br>**Memory:** N/A<br>**Root Disk:** N/A"
}

func getVMsUsingSecurityGroup(sgName string, targetDetails *summary.TargetInfraSummary) string {
	if targetDetails == nil || targetDetails.ComputeResources.Vms == nil {
		return "N/A"
	}

	vms := []string{}
	for _, vm := range targetDetails.ComputeResources.Vms {
		for _, sg := range vm.Misc.SecurityGroups {
			if sg == sgName {
				vms = append(vms, vm.Name)
				break
			}
		}
	}

	if len(vms) == 0 {
		return "N/A"
	}

	return strings.Join(vms, "<br>")
}

func getVMsUsingSecurityGroupList(sgName string, targetDetails *summary.TargetInfraSummary) []string {
	vms := []string{}
	if targetDetails == nil || targetDetails.ComputeResources.Vms == nil {
		return vms
	}

	for _, vm := range targetDetails.ComputeResources.Vms {
		for _, sg := range vm.Misc.SecurityGroups {
			if sg == sgName {
				vms = append(vms, vm.Name)
				break
			}
		}
	}

	return vms
}

func matchSourceFirewallRule(rule summary.SummaryFirewallRule, sourceDetails *summary.SourceInfraSummary) string {
	if sourceDetails == nil || sourceDetails.SecurityResources.ServerFirewalls == nil {
		return "-"
	}

	// Enhanced matching logic
	for _, serverFw := range sourceDetails.SecurityResources.ServerFirewalls {
		for _, sourceRule := range serverFw.FirewallRules {
			// Match by direction first
			directionMatch := strings.EqualFold(sourceRule.Direction, rule.Direction)
			if !directionMatch {
				continue
			}

			// Match by protocol (handle "ALL" case)
			protocolMatch := false
			if strings.EqualFold(rule.Protocol, "ALL") || strings.EqualFold(rule.Protocol, "-1") {
				protocolMatch = true
			} else {
				protocolMatch = strings.EqualFold(sourceRule.Protocol, rule.Protocol)
			}
			if !protocolMatch {
				continue
			}

			// Match by CIDR
			// For inbound rules, compare with source CIDR
			// Both must match or one must be wildcard (0.0.0.0/0)
			cidrMatch := false
			if rule.Cidr == sourceRule.SrcCIDR {
				cidrMatch = true
			} else if rule.Cidr == "0.0.0.0/0" && sourceRule.SrcCIDR == "0.0.0.0/0" {
				cidrMatch = true
			}
			if !cidrMatch {
				continue
			}

			// Match by port (handle multiple ports separated by comma, and empty ports for ALL protocol)
			portMatch := false
			if rule.FromPort == "" || strings.EqualFold(rule.Protocol, "ALL") {
				// For ALL protocol or empty port, consider it a match
				portMatch = true
			} else if sourceRule.DstPorts == rule.FromPort {
				// Exact match
				portMatch = true
			} else if strings.Contains(sourceRule.DstPorts, ",") {
				// Check if the port is in comma-separated list
				ports := strings.Split(sourceRule.DstPorts, ",")
				for _, p := range ports {
					if strings.TrimSpace(p) == rule.FromPort {
						portMatch = true
						break
					}
				}
			}

			if portMatch {
				// Format: direction protocol port [action]
				ruleStr := fmt.Sprintf("%s %s %s", sourceRule.Direction, sourceRule.Protocol, sourceRule.DstPorts)
				if sourceRule.Action != "" && sourceRule.Action != "allow" {
					ruleStr += fmt.Sprintf(" (%s)", sourceRule.Action)
				}
				if sourceRule.SrcCIDR != "" && sourceRule.SrcCIDR != "0.0.0.0/0" {
					ruleStr += fmt.Sprintf(" from %s", sourceRule.SrcCIDR)
				}
				return ruleStr
			}
		}
	}

	return "-"
}

func writeMigrationMappings(md *strings.Builder, mappings []SourceTargetMapping) {
	md.WriteString("## üîÑ Migration Mappings\n\n")
	md.WriteString("Correlation between source servers and target cloud VMs:\n\n")

	for i, mapping := range mappings {
		md.WriteString(fmt.Sprintf("### %d. %s ‚Üí %s\n\n", i+1, mapping.SourceServer.Hostname, mapping.TargetVM.InstanceName))

		// Server Details Table
		md.WriteString("| Aspect | Source (On-Premise) | Target (Cloud) | Analysis |\n")
		md.WriteString("|--------|---------------------|----------------|----------|\n")

		// Machine/Instance ID
		md.WriteString(fmt.Sprintf("| **ID** | %s | %s | ‚úÖ Mapped |\n",
			formatIfEmpty(mapping.SourceServer.MachineID, "N/A"),
			formatIfEmpty(mapping.TargetVM.InstanceID, "N/A")))

		// Status
		md.WriteString(fmt.Sprintf("| **Status** | - | %s | %s |\n",
			formatIfEmpty(mapping.TargetVM.Status, "Unknown"),
			formatIfEmpty(mapping.MigrationStatus, "Unknown")))

		// OS
		md.WriteString(fmt.Sprintf("| **OS** | %s | - | - |\n",
			formatIfEmpty(mapping.SourceServer.OSName, "Unknown")))

		// Compute - CPU with detailed calculation
		sourceCPUInfo := fmt.Sprintf("%d CPUs √ó %d threads", mapping.SourceServer.CPUs, mapping.SourceServer.CPUThreads)
		if mapping.SourceServer.CPUModel != "" {
			sourceCPUInfo = fmt.Sprintf("%d CPUs √ó %d threads (%s)", mapping.SourceServer.CPUs, mapping.SourceServer.CPUThreads, mapping.SourceServer.CPUModel)
		}
		cpuAnalysis := formatCPUMatching(mapping.SourceServer.CPUs, mapping.SourceServer.CPUThreads, mapping.TargetVM.VCPUs)
		md.WriteString(fmt.Sprintf("| **CPU** | %s | %d vCPUs | %s |\n",
			sourceCPUInfo,
			mapping.TargetVM.VCPUs,
			cpuAnalysis))

		md.WriteString(fmt.Sprintf("| **Memory** | %d GB | %.1f GB | %s |\n",
			mapping.SourceServer.MemoryGB,
			mapping.TargetVM.MemoryGB,
			formatResourceChangeFloat(mapping.SourceServer.MemoryGB, int(mapping.TargetVM.MemoryGB))))

		md.WriteString(fmt.Sprintf("| **Storage** | %d GB (%s) | %d GB (%s) | %s |\n",
			mapping.SourceServer.DiskGB,
			formatIfEmpty(mapping.SourceServer.DiskType, "N/A"),
			mapping.TargetVM.RootDiskGB,
			formatIfEmpty(mapping.TargetVM.RootDiskType, "N/A"),
			formatResourceChange(mapping.SourceServer.DiskGB, mapping.TargetVM.RootDiskGB)))

		// Network
		md.WriteString(fmt.Sprintf("| **Network** | %s | %s (Public)<br>%s (Private) | IP assigned |\n",
			formatIfEmpty(mapping.SourceServer.PrimaryIP, "N/A"),
			formatIfEmpty(mapping.TargetVM.PublicIP, "N/A"),
			formatIfEmpty(mapping.TargetVM.PrivateIP, "N/A")))

		// Security
		sgList := "N/A"
		if len(mapping.TargetVM.SecurityGroups) > 0 {
			sgList = strings.Join(mapping.TargetVM.SecurityGroups, ", ")
		}
		md.WriteString(fmt.Sprintf("| **Security** | %d firewall rules | %s | Configured |\n",
			mapping.SourceServer.FirewallRules,
			sgList))

		// VM Spec
		md.WriteString(fmt.Sprintf("| **Instance Type** | - | %s | Cloud spec |\n\n",
			formatIfEmpty(mapping.TargetVM.SpecName, "N/A")))

		// Cost per month
		if mapping.CostPerMonth > 0 {
			md.WriteString(fmt.Sprintf("**üí∞ Monthly Cost:** $%.2f USD\n\n", mapping.CostPerMonth))
		}

		// Resource Change Analysis
		writeResourceChanges(md, &mapping.ResourceChanges)

		md.WriteString("\n")
	}

	md.WriteString("---\n\n")
}

func writeResourceChanges(md *strings.Builder, changes *ResourceChangeAnalysis) {
	md.WriteString("#### üìà Resource Changes\n\n")

	hasChanges := false

	if changes.CPUChange.Description != "" {
		md.WriteString(fmt.Sprintf("- **CPU:** %s (%s)\n", changes.CPUChange.Description, changes.CPUChange.ChangeType))
		hasChanges = true
	}
	if changes.MemoryChange.Description != "" {
		md.WriteString(fmt.Sprintf("- **Memory:** %s (%s)\n", changes.MemoryChange.Description, changes.MemoryChange.ChangeType))
		hasChanges = true
	}
	if changes.StorageChange.Description != "" {
		md.WriteString(fmt.Sprintf("- **Storage:** %s (%s)\n", changes.StorageChange.Description, changes.StorageChange.ChangeType))
		hasChanges = true
	}
	if changes.NetworkChange.Description != "" {
		md.WriteString(fmt.Sprintf("- **Network:** %s (%s)\n", changes.NetworkChange.Description, changes.NetworkChange.ChangeType))
		hasChanges = true
	}
	if changes.SecurityChange.Description != "" {
		md.WriteString(fmt.Sprintf("- **Security:** %s (%s)\n", changes.SecurityChange.Description, changes.SecurityChange.ConversionStatus))
		hasChanges = true
	}

	if !hasChanges {
		md.WriteString("*No significant changes detected*\n")
	}

	md.WriteString("\n")
}

func writeNetworkAnalysis(md *strings.Builder, analysis *NetworkMigrationAnalysis) {
	md.WriteString("## üåê Network Migration Analysis\n\n")

	// Source Network
	md.WriteString("### Source Network\n\n")
	md.WriteString(fmt.Sprintf("- **CIDR:** %s\n", analysis.SourceNetwork.CIDR))
	md.WriteString(fmt.Sprintf("- **Gateway:** %s\n", analysis.SourceNetwork.Gateway))
	md.WriteString(fmt.Sprintf("- **Connected Servers:** %d\n\n", analysis.SourceNetwork.ConnectedServers))

	// Target Network
	md.WriteString("### Target Network\n\n")
	md.WriteString(fmt.Sprintf("- **VNet Name:** %s\n", analysis.TargetNetwork.VNetName))
	md.WriteString(fmt.Sprintf("- **VNet CIDR:** %s\n", analysis.TargetNetwork.VNetCIDR))
	md.WriteString(fmt.Sprintf("- **Subnet CIDR:** %s\n", analysis.TargetNetwork.SubnetCIDR))
	md.WriteString(fmt.Sprintf("- **CSP VNet ID:** %s\n\n", analysis.TargetNetwork.CSPVNetID))

	// IP Address Mappings
	if len(analysis.IPMappings) > 0 {
		md.WriteString("### IP Address Mappings\n\n")
		md.WriteString("| Source Hostname | Source IP | Target Private IP | Target Public IP | Status |\n")
		md.WriteString("|----------------|-----------|-------------------|------------------|--------|\n")

		for _, mapping := range analysis.IPMappings {
			status := "‚úÖ Mapped"
			if mapping.TargetPublicIP == "" && mapping.TargetPrivateIP == "" {
				status = "‚ö†Ô∏è Not mapped"
			}
			md.WriteString(fmt.Sprintf("| %s | %s | %s | %s | %s |\n",
				formatIfEmpty(mapping.SourceHostname, "N/A"),
				formatIfEmpty(mapping.SourceIP, "N/A"),
				formatIfEmpty(mapping.TargetPrivateIP, "N/A"),
				formatIfEmpty(mapping.TargetPublicIP, "N/A"),
				status))
		}
		md.WriteString("\n")
	}

	// CIDR Preservation Status
	md.WriteString("### CIDR Preservation\n\n")
	if analysis.CIDRPreserved {
		md.WriteString("‚úÖ CIDR preserved in target VNet\n\n")
	} else {
		md.WriteString("‚ö†Ô∏è CIDR changed in target VNet\n\n")
	}

	// Description
	if analysis.Description != "" {
		md.WriteString(fmt.Sprintf("**Analysis:** %s\n\n", analysis.Description))
	}

	md.WriteString("---\n\n")
}

func writeSecurityAnalysis(md *strings.Builder, analysis *SecurityMigrationAnalysis) {
	md.WriteString("## üîí Security Migration Analysis\n\n")

	// Firewall Rule Conversions
	if len(analysis.Conversions) > 0 {
		md.WriteString("### Firewall Rule Conversions\n\n")
		md.WriteString("| Source Hostname | Source Rules | Target SG | Target Rules | Conversion Type | Status |\n")
		md.WriteString("|----------------|--------------|-----------|--------------|-----------------|--------|\n")

		totalSourceRules := 0
		totalTargetRules := 0
		for _, conv := range analysis.Conversions {
			totalSourceRules += conv.SourceRules
			totalTargetRules += conv.TargetRules
			md.WriteString(fmt.Sprintf("| %s | %d | %s | %d | %s | %s |\n",
				formatIfEmpty(conv.SourceHostname, "N/A"),
				conv.SourceRules,
				formatIfEmpty(conv.TargetSGName, "N/A"),
				conv.TargetRules,
				formatIfEmpty(conv.ConversionType, "N/A"),
				formatConversionStatus(conv.Status == "Converted")))
		}
		md.WriteString("\n")

		md.WriteString(fmt.Sprintf("**Total Source Rules:** %d | **Total Target Rules:** %d\n\n", totalSourceRules, totalTargetRules))
	}

	// Summary
	if analysis.Summary != "" {
		md.WriteString(fmt.Sprintf("**Summary:** %s\n\n", analysis.Summary))
	}

	md.WriteString("---\n\n")
}

func writeCostSummary(md *strings.Builder, summary *CostSummary) {
	md.WriteString("## üí∞ Cost Summary\n\n")

	// Total Costs
	md.WriteString("### Total Estimated Costs\n\n")
	md.WriteString("| Period | Cost (USD) |\n")
	md.WriteString("|--------|------------|\n")
	md.WriteString(fmt.Sprintf("| Hourly | $%.4f |\n", summary.TotalHourlyCost))
	md.WriteString(fmt.Sprintf("| Daily | $%.2f |\n", summary.TotalDailyCost))
	md.WriteString(fmt.Sprintf("| Monthly | $%.2f |\n", summary.TotalMonthlyCost))
	md.WriteString(fmt.Sprintf("| Yearly | $%.2f |\n\n", summary.TotalYearlyCost))

	// Cost by Component
	if len(summary.CostByComponent) > 0 {
		md.WriteString("### Cost Breakdown by Component\n\n")
		md.WriteString("| Component | Spec | Monthly Cost | Percentage |\n")
		md.WriteString("|-----------|------|--------------|------------|\n")

		for _, comp := range summary.CostByComponent {
			md.WriteString(fmt.Sprintf("| %s | %s | $%.2f | %.1f%% |\n",
				comp.ComponentName,
				formatIfEmpty(comp.SpecName, "N/A"),
				comp.MonthlyCost,
				comp.CostPercentage))
		}
		md.WriteString("\n")
	}

	md.WriteString("---\n\n")
}

func writeRecommendations(md *strings.Builder, recommendations []Recommendation) {
	md.WriteString("## üí° Recommendations\n\n")

	// Group by category
	categories := make(map[string][]Recommendation)
	for _, rec := range recommendations {
		categories[rec.Category] = append(categories[rec.Category], rec)
	}

	// Priority order
	priorityOrder := []string{"critical", "high", "medium", "low"}
	categoryOrder := []string{"cost", "performance", "security", "storage", "network", "monitoring", "optimization"}

	for _, category := range categoryOrder {
		recs, exists := categories[category]
		if !exists || len(recs) == 0 {
			continue
		}

		md.WriteString(fmt.Sprintf("### %s %s\n\n", getCategoryEmoji(category), strings.Title(category)))

		for _, priority := range priorityOrder {
			for _, rec := range recs {
				if rec.Priority == priority {
					icon := getPriorityIcon(rec.Priority)
					md.WriteString(fmt.Sprintf("**%s %s** (%s)\n\n", icon, rec.Title, rec.Priority))
					md.WriteString(fmt.Sprintf("%s\n\n", rec.Description))

					if len(rec.ActionItems) > 0 {
						md.WriteString("Action items:\n\n")
						for _, item := range rec.ActionItems {
							md.WriteString(fmt.Sprintf("- %s\n", item))
						}
						md.WriteString("\n")
					}
				}
			}
		}
	}

	md.WriteString("---\n\n")
}

// Helper functions

func calculatePercentageChange(source, target int) float64 {
	if source == 0 {
		if target == 0 {
			return 0.0
		}
		return 100.0
	}
	return float64(target-source) / float64(source) * 100.0
}

func formatIfEmpty(value, defaultValue string) string {
	if value == "" {
		return defaultValue
	}
	return value
}

func formatComparisonStatus(source, target string) string {
	if source == "" || target == "" {
		return "‚ö†Ô∏è Unknown"
	}
	if strings.Contains(strings.ToLower(source), strings.ToLower(target)) ||
		strings.Contains(strings.ToLower(target), strings.ToLower(source)) {
		return "‚úÖ Compatible"
	}
	return "‚ö†Ô∏è Changed"
}

func formatResourceChange(source, target int) string {
	if target == source {
		return "‚Üí Same"
	} else if target > source {
		pct := calculatePercentageChange(source, target)
		return fmt.Sprintf("‚ÜóÔ∏è +%d (+%.1f%%)", target-source, pct)
	} else {
		pct := calculatePercentageChange(source, target)
		return fmt.Sprintf("‚ÜòÔ∏è %d (%.1f%%)", target-source, pct)
	}
}

func formatResourceChangeFloat(source int, target int) string {
	if target == source {
		return "‚Üí Same"
	} else if target > source {
		pct := calculatePercentageChange(source, target)
		return fmt.Sprintf("‚ÜóÔ∏è +%d (+%.1f%%)", target-source, pct)
	} else {
		pct := calculatePercentageChange(source, target)
		return fmt.Sprintf("‚ÜòÔ∏è %d (%.1f%%)", target-source, pct)
	}
}

func formatConversionStatus(converted bool) string {
	if converted {
		return "‚úÖ Converted"
	}
	return "‚ö†Ô∏è Pending"
}

// formatCPUMatching analyzes CPUs √ó threads to vCPU matching and returns status string
func formatCPUMatching(sourceCPUs int, sourceThreads int, targetVCPUs int) string {
	// Actual mapping: CPUs (sockets) √ó CPU Threads = Expected vCPUs
	// Example: 1 CPU √ó 16 threads = 16 vCPUs
	// Scenarios:
	// - Perfect match: source CPUs √ó threads = target vCPUs
	// - Overprovisioned: target vCPUs > source CPUs √ó threads
	// - Underprovisioned: target vCPUs < source CPUs √ó threads

	expectedVCPUs := sourceCPUs * sourceThreads

	if targetVCPUs == expectedVCPUs {
		return fmt.Sprintf("‚úÖ Matched (%d√ó%d=%d)", sourceCPUs, sourceThreads, expectedVCPUs)
	} else if targetVCPUs > expectedVCPUs {
		extra := targetVCPUs - expectedVCPUs
		pct := float64(extra) / float64(expectedVCPUs) * 100
		return fmt.Sprintf("‚ÜóÔ∏è +%d vCPUs (+%.0f%%) [expected: %d√ó%d=%d]", extra, pct, sourceCPUs, sourceThreads, expectedVCPUs)
	} else {
		deficit := expectedVCPUs - targetVCPUs
		pct := float64(deficit) / float64(expectedVCPUs) * 100
		return fmt.Sprintf("‚ÜòÔ∏è -%d vCPUs (-%.0f%%) [expected: %d√ó%d=%d]", deficit, pct, sourceCPUs, sourceThreads, expectedVCPUs)
	}
}

func getCategoryEmoji(category string) string {
	emojiMap := map[string]string{
		"cost":         "üí∞",
		"performance":  "‚ö°",
		"security":     "üîí",
		"storage":      "üíæ",
		"network":      "üåê",
		"monitoring":   "üìä",
		"optimization": "üéØ",
	}
	if emoji, ok := emojiMap[category]; ok {
		return emoji
	}
	return "üìå"
}

func getPriorityIcon(priority string) string {
	switch priority {
	case "critical":
		return "üî¥"
	case "high":
		return "üü†"
	case "medium":
		return "üü°"
	case "low":
		return "üü¢"
	default:
		return "‚ö™"
	}
}
